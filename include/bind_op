// <bind_op> -*- C++ -*-
// Copyright 2016 Jeremy Letang.
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#include <type_traits>
#include <functional>
#include <algorithm>
#include <string>
#include <array>

#if __cplusplus >= 201402L
# include <experimental/optional>
#elif __cplusplus >= 201701L
# include <optional>
#endif

namespace bind_op {

#if __cplusplus >= 201402L
namespace  _std_opt = std::experimental;
#elif __cplusplus >= 201701L
namespace _std_opt = std;
#endif

namespace detail {

template<typename T>
struct has_const_iterator {
private:
    template<typename C> static char test(typename C::const_iterator*);
    template<typename C> static int  test(...);
public:
    enum { value = sizeof(test<T>(0)) == sizeof(char) };
};

} // detail

template <
  typename T,
  typename F,
  typename = std::enable_if_t<
    std::is_convertible<
      F,
      std::function<decltype(std::declval<F>()((std::declval<T>())))(const T&)
    >
  >::value>
>
auto operator>>=(const _std_opt::optional<T>& lhs, F f) -> decltype(auto) {
  if (lhs == _std_opt::nullopt) {
    decltype(_std_opt::make_optional(f(*lhs))) nul = _std_opt::nullopt;
    return nul;
  }
  return _std_opt::make_optional(f(*lhs));
}

template <
  template<typename Ty, typename... Args> class C,
  typename T,
  typename F,
  typename = std::enable_if_t<detail::has_const_iterator<C<T>>::value>
>
auto operator>>=(const C<T>& lhs, F f) -> decltype(auto) {
  // create the output container with the size of the input one
  C<decltype(f(std::declval<T>()))> out(lhs.size());
  std::transform(std::cbegin(lhs), std::cend(lhs), std::begin(out), f);
  return out;
}

template <
  typename CharT,
  typename Traits,
  typename Allocator,
  typename F
>
auto operator>>=(const std::basic_string<CharT, Traits, Allocator>& lhs, F f)
  -> decltype(auto) {
  // create the output string with the size of the input one
  std::basic_string<CharT, Traits, Allocator> out(lhs.size(), CharT{});
  std::transform(std::cbegin(lhs), std::cend(lhs), std::begin(out), f);
  return out;
}

template <
  typename T,
  typename F,
  size_t N
>
auto operator>>=(const std::array<T, N>& lhs, F f)
  -> decltype(auto) {
  // create the output string with the size of the input one
  std::array<decltype(f(std::declval<T>())), N> out;
  std::transform(std::cbegin(lhs), std::cend(lhs), std::begin(out), f);
  return out;
}

} // bind_op
